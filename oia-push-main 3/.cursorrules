# Cursor Rules para Projeto Ã“ia Push - React E-commerce

## ğŸ¯ Contexto do Projeto
VocÃª Ã© um especialista em desenvolvimento React, TypeScript, e sistemas de e-commerce com foco em tracking de conversÃµes e campanhas UTM. Este projeto Ã© um cardÃ¡pio digital para hamburgeria com sistema de carrinho, checkout e rastreamento avanÃ§ado de marketing.

## ğŸš€ Stack TecnolÃ³gica Principal
- **Frontend**: React 18.3.1 + TypeScript 5.5.3 + Vite 5.4.1
- **Estado**: Zustand 5.0.6 (com persistÃªncia localStorage)
- **EstilizaÃ§Ã£o**: Tailwind CSS 3.4.11 + Shadcn/UI + Radix UI
- **Roteamento**: React Router Dom 6.26.2
- **Cache/Requests**: TanStack Query 5.56.2
- **FormulÃ¡rios**: React Hook Form 7.53.0 + Zod 3.23.8
- **AnimaÃ§Ãµes**: Framer Motion 12.23.3
- **HTTP**: Axios 1.10.0

## ğŸ“ Estrutura de Pastas ObrigatÃ³ria
```
src/
â”œâ”€â”€ components/     # Componentes reutilizÃ¡veis
â”œâ”€â”€ pages/         # PÃ¡ginas da aplicaÃ§Ã£o
â”œâ”€â”€ hooks/         # Hooks customizados
â”œâ”€â”€ services/      # ServiÃ§os (APIs, integraÃ§Ã£o)
â”œâ”€â”€ types/         # DefiniÃ§Ãµes TypeScript
â”œâ”€â”€ utils/         # FunÃ§Ãµes utilitÃ¡rias
â”œâ”€â”€ assets/        # Recursos estÃ¡ticos
â””â”€â”€ lib/          # ConfiguraÃ§Ãµes e bibliotecas
```

## ğŸ¨ PadrÃµes de CÃ³digo

### Componentes React
```tsx
// âœ… SEMPRE use este padrÃ£o
import { FC } from 'react'
import { ComponentNameProps } from './types'

const ComponentName: FC<ComponentNameProps> = ({ 
  prop1,
  prop2,
  ...props 
}) => {
  // LÃ³gica do componente

  return (
    <div className="tailwind-classes">
      {/* JSX aqui */}
    </div>
  )
}

export default ComponentName
```

### Hooks Zustand
```tsx
// âœ… SEMPRE use este padrÃ£o para stores Zustand
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface StoreState {
  // estado aqui
}

interface StoreActions {
  // aÃ§Ãµes aqui
}

export const useStore = create<StoreState & StoreActions>()(
  persist(
    (set, get) => ({
      // implementaÃ§Ã£o aqui
    }),
    {
      name: 'store-name',
      // adicione partialize se necessÃ¡rio
    }
  )
)
```

### ServiÃ§os
```tsx
// âœ… SEMPRE use este padrÃ£o para serviÃ§os
class ServiceName {
  private static instance: ServiceName
  
  static getInstance(): ServiceName {
    if (!ServiceName.instance) {
      ServiceName.instance = new ServiceName()
    }
    return ServiceName.instance
  }

  async methodName(params: ParamsType): Promise<ReturnType> {
    // implementaÃ§Ã£o com try/catch e retry logic
  }
}

export const serviceName = ServiceName.getInstance()
```

## ğŸ”¥ Regras EspecÃ­ficas do Projeto

### Sistema UTM (CRÃTICO)
```tsx
// âœ… SEMPRE preserve parÃ¢metros UTM em links internos
import { useUtm } from '@/hooks/useUtm'

const UtmPreservingLink: FC<LinkProps> = ({ to, children, ...props }) => {
  const { getUtmParams } = useUtm()
  const utmParams = getUtmParams()
  
  const urlWithUtm = useMemo(() => {
    const url = new URL(to, window.location.origin)
    Object.entries(utmParams).forEach(([key, value]) => {
      if (value) url.searchParams.set(key, value)
    })
    return url.pathname + url.search
  }, [to, utmParams])

  return <Link to={urlWithUtm} {...props}>{children}</Link>
}
```

### Carrinho de Compras
```tsx
// âœ… SEMPRE use este padrÃ£o para itens do carrinho
interface CartItem {
  id: string
  name: string
  price: number
  quantity: number
  customizations?: Record<string, any>
  image?: string
  category?: string
}

// âœ… SEMPRE implemente estas funÃ§Ãµes no store do carrinho
const useCartStore = create<CartState & CartActions>()(
  persist(
    (set, get) => ({
      items: [],
      addItem: (item) => { /* lÃ³gica de adiÃ§Ã£o */ },
      removeItem: (itemId) => { /* lÃ³gica de remoÃ§Ã£o */ },
      updateQuantity: (itemId, quantity) => { /* lÃ³gica de atualizaÃ§Ã£o */ },
      clearCart: () => set({ items: [] }),
      getTotalPrice: () => { /* cÃ¡lculo do total */ },
      getTotalItems: () => { /* cÃ¡lculo de itens */ },
    }),
    { name: 'cart-storage' }
  )
)
```

### FormulÃ¡rios com React Hook Form + Zod
```tsx
// âœ… SEMPRE use este padrÃ£o para formulÃ¡rios
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  // definiÃ§Ã£o do schema
})

type FormData = z.infer<typeof schema>

const FormComponent: FC = () => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<FormData>({
    resolver: zodResolver(schema),
  })

  const onSubmit = async (data: FormData) => {
    // lÃ³gica de submit
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* campos do formulÃ¡rio */}
    </form>
  )
}
```

## ğŸš¨ REGRAS CRÃTICAS - NUNCA FAÃ‡A ISSO

### âŒ NUNCA use estas prÃ¡ticas:
```tsx
// âŒ NUNCA use useState para dados que precisam persistir
const [cartItems, setCartItems] = useState([]) // Use Zustand!

// âŒ NUNCA esqueÃ§a de preservar UTM em navegaÃ§Ã£o
<Link to="/checkout"> // Sempre use UtmPreservingLink!

// âŒ NUNCA faÃ§a requisiÃ§Ãµes sem tratamento de erro
const data = await axios.get('/api/data') // Sempre use try/catch!

// âŒ NUNCA use any em TypeScript
const handleClick = (event: any) => {} // Sempre type corretamente!

// âŒ NUNCA coloque lÃ³gica de negÃ³cio em componentes UI
const ProductCard = () => {
  // âŒ lÃ³gica complexa aqui
  const calculateDiscount = () => {} // Mova para hook ou service!
}
```

## ğŸ¯ OtimizaÃ§Ãµes EspecÃ­ficas

### Performance
```tsx
// âœ… SEMPRE use memo para componentes pesados
import { memo, useMemo, useCallback } from 'react'

const ExpensiveComponent = memo<Props>(({ data, onAction }) => {
  const processedData = useMemo(() => {
    return data.map(/* processamento pesado */)
  }, [data])

  const handleAction = useCallback((id: string) => {
    onAction(id)
  }, [onAction])

  return <div>{/* render */}</div>
})
```

### Error Boundaries
```tsx
// âœ… SEMPRE implemente Error Boundaries para componentes crÃ­ticos
class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />
    }
    return this.props.children
  }
}
```

## ğŸ“± Responsividade com Tailwind
```tsx
// âœ… SEMPRE use classes responsivas do Tailwind
<div className="
  grid grid-cols-1 gap-4
  sm:grid-cols-2 sm:gap-6
  md:grid-cols-3 md:gap-8
  lg:grid-cols-4 lg:gap-10
  xl:grid-cols-5
">
  {/* conteÃºdo */}
</div>
```

## ğŸ§ª Testing Patterns
```tsx
// âœ… SEMPRE teste componentes crÃ­ticos
import { render, screen, fireEvent } from '@testing-library/react'
import { vi } from 'vitest'

describe('ProductCard', () => {
  it('should add item to cart when clicked', async () => {
    const mockAddItem = vi.fn()
    render(<ProductCard product={mockProduct} onAddToCart={mockAddItem} />)
    
    const addButton = screen.getByRole('button', { name: /adicionar/i })
    fireEvent.click(addButton)
    
    expect(mockAddItem).toHaveBeenCalledWith(mockProduct)
  })
})
```

## ğŸ“Š Monitoring e Analytics
```tsx
// âœ… SEMPRE implemente tracking de conversÃµes
const trackConversion = async (event: ConversionEvent) => {
  try {
    await utmifyService.trackConversion({
      event,
      utmParams: getUtmParams(),
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    // Armazene para retry posterior
    await storeFailedConversion(event)
  }
}
```

## ğŸ”’ ValidaÃ§Ã£o e SeguranÃ§a
```tsx
// âœ… SEMPRE valide dados de entrada
const sanitizeInput = (input: string): string => {
  return input.trim().replace(/[<>]/g, '')
}

// âœ… SEMPRE use validaÃ§Ã£o de schema
const validateCartItem = (item: unknown): CartItem => {
  return cartItemSchema.parse(item)
}
```

## ğŸš€ Deploy e Build
```bash
# âœ… SEMPRE verifique antes do deploy
npm run type-check    # VerificaÃ§Ã£o de tipos
npm run lint         # Linting
npm run test        # Testes
npm run build       # Build de produÃ§Ã£o
```

## ğŸ’¡ Dicas de Produtividade

1. **Use snippets personalizados** para padrÃµes frequentes
2. **Configure auto-imports** para sua estrutura de pastas
3. **Use o Cursor Tab** para completar cÃ³digo baseado no contexto
4. **Aproveite o Chat** para refatoraÃ§Ãµes e otimizaÃ§Ãµes
5. **Configure formataÃ§Ã£o automÃ¡tica** no save

## ğŸ¯ Comandos Ãšteis do Cursor

- `Cmd+K` - Chat rÃ¡pido
- `Cmd+L` - Chat com contexto
- `Cmd+I` - EdiÃ§Ã£o inline
- `Tab` - Aceitar sugestÃ£o
- `Cmd+Shift+E` - Explain code

---

**Lembre-se**: Sempre priorize a experiÃªncia do usuÃ¡rio, performance e rastreamento de conversÃµes. Este projeto Ã© crÃ­tico para o negÃ³cio do restaurante!